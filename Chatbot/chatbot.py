import random
import re
from datetime import datetime
import string
from collections import Counter


class LocalChatbot:
    def __init__(self):
        self.name = "PortfolioBot"
        self.first_message = True
        self.conversation_active = False

        # Dictionnaire des corrections orthographiques
        self.spelling_corrections = {
            "salu": "salut",
            "bonjour": "Bonjour",
            "projek": "projet",
            "realisation": "r√©alisation",
            "portefeuil": "portfolio",
            "montr√©": "montrez",
            "av√©": "avez",
            "f√©": "fait",
            "aplikation": "application",
            "o'foot": "O'Foot",
            "ofliks": "Oflix",
            "tournoit": "tournoi",
            "film": "film",
            "seri": "s√©rie",
            "interaktif": "interactif",
            "exp√©riance": "exp√©rience",
            "parcour": "parcours",
            "travail": "travail",
            "professionnel": "professionnelle",
            "entreprise": "entreprise",
            "travaill√©": "travaill√©",
            "formassion": "formation",
            "etude": "√©tudes",
            "dipl√¥me": "dipl√¥mes",
            "√©cole": "√©cole",
            "universit√©": "universit√©",
            "curse": "cursus",
            "d√©veloppeur": "d√©veloppeur",
            "deveop": "devops",
            "manifik": "magnifique",
            "genial": "g√©nial",
            "excelent": "excellent",
            "terible": "terrible",
            "pourit": "pourri",
            "Quel est mon age": "quel est mon √¢ge"
        }

        # D√©tails des projets
        self.project_details = {
            "ofoot": "O'Foot est une application web d√©velopp√©e en PHP/Symfony permettant la gestion compl√®te de tournois de football. Elle inclut la cr√©ation d'√©quipes, la gestion des matchs, le suivi des scores et un tableau des classements en temps r√©el.\n\n\n",
            "oflix": "Oflix est une plateforme de streaming d√©velopp√©e en PHP/Symfony, permettant de g√©rer et visualiser un catalogue de films et s√©ries. Elle comprend un syst√®me de notation, des critiques utilisateurs et des recommandations personnalis√©es.\n\n\n",
            "portfolio": "Un portfolio interactif pr√©sentant mes projets et comp√©tences, avec un chatbot int√©gr√© permettant une navigation intuitive et une pr√©sentation dynamique de mon travail.\n\n\n"
        }

        # Base de connaissances
        self.knowledge_base = {
            "greetings": {
                "patterns": [
                    r"^salut$",
                    r"^bonjour$"
                ],
                "responses": [
                    "Salut ! Je suis ravi de vous rencontrer. Je suis Mohammad-Qassem, d√©veloppeur web fullstack et Data Scientist. Souhaitez-vous discuter de mon parcours, de mes comp√©tences, de mes exp√©riences ou de mes projets ?"
                ]
            },

            "expertise": {
                "patterns": [
                    r"comp√©tences?.*",
                    r"connaissances?.*",
                    r"capacit√©s?.*",
                    r"que sais[-\s]tu faire.*",
                    r"quelles? sont? tes? comp√©tences?.*",
                    r"quelles? technologies?.*",
                    r"stack.*technique.*",
                    r"savoir[-\s]faire.*"
                ],
                "responses": [
                    "Voici mes comp√©tences techniques :Comp√©tences :\nüë®‚Äçüíª Langages : HTML5, CSS3, PHP 8, JavaScript, Python, MySQL\n\nüõ† Frameworks : Symfony, Laravel, Django, Flask, Bootstrap, Tailwind CSS, Pandas, Seaborn, Numpy\n\nüîß Outils : Git, VS Code, Jetbrains, MySQL\n\nüåê M√©thodologies : Agile/Scrum, Architecture MVC, API REST\n\nüõ† DevOps : Docker, Hidora, Heroku"
                ]
            },

            "projets": {
                "patterns": [
                    r"projet.*",
                    r"r√©alisation.*",
                    r"portfolio.*",
                    r"montr[ez]?\s*[- ]?moi.*",
                    r"qu['']av[ez]?\s*[- ]?vous\s*fait.*",
                    r"application.*"
                ],
                "responses": [
                    "J'ai 2 projets principaux :\n\n1. O'Foot - Gestion de tournois\n2. Oflix - Streaming de films\n\nSur lequel souhaitez-vous en savoir plus ?"

                ]
            },
            "projet_details": {
                "patterns": [
                    r".*o'?foot.*",
                    r".*oflix.*",
                    r".*tournoi.*foot.*",
                    r".*film.*s√©rie.*",
                    r".*portfolio.*interactif.*"
                ],
                "responses": [
                    lambda x: self.get_project_details(x)
                ]
            },

            "experience": {
                "patterns": [
                    r"exp√©riences?.*",
                    r"travail.*",
                    r"professionnelle?.*",
                    r"entreprise.*",
                    r"o√π\s*([a√†]|avez)[-\s]vous\s*travaill√©.*"
                ],
                "responses": [
                    "Mon parcours professionnel inclut :\n\n1. D√©veloppeur Web Fullstack (Juin-Juillet 2024) chez O'Clock - O'Foot\n\n2. Stage (D√©cembre 2022) chez EpetitPas - Page Formateur"
                ]
            },

            "formation": {
                "patterns": [
                    r"formation.*",
                    r"√©tudes.*",
                    r"dipl√¥mes?.*",
                    r"√©cole.*",
                    r"universit√©.*",
                    r"cursus.*",
                    r"parcours.*",
                    r"parcours.*formation.*",
                    r"parcours.*acad√©mique.*",
                    r"parcours.*scolaire.*",
                    r"formation.*suivie.*",
                    r"o√π.*√©tudi√©.*",
                    r"quelle.*formation.*"
                ],
                "responses": [
                    "Je dispose de 3 formations :\n\n1. Titre Pro D√©veloppeur Web (O'Clock, 2024)\n2. Formation Dev Web Remise √† Niveau (Assofac, 2022)\n3. BAC STMG (Lyc√©e A. Nobel, 2021)"
                ]
            },
            # [Other existing patterns remain the same]

            # S√©paration des expertises en deux cat√©gories distinctes
            "dev_web": {
                "patterns": [
                    r"d√©veloppeur\s*web",
                    r"d√©veloppement\s*web",
                    r"web\s*developer"
                ],
                "responses": [
                    "En tant que d√©veloppeur web, je ma√Ætrise les technologies suivantes :\n\n\n- PHP/Symfony\n\n\n- JavaScript\n\n\n- HTML/CSS\n\n\n- MySQL\n\n\n- Bootstrap\n\n\n- Je peux concevoir et d√©velopper des applications web compl√®tes, du backend au frontend."
                ]
            },

            "devops": {
                "patterns": [
                    r"data",
                    r"dataScience",
                    r"data science",
                    r"machine learning",
                    r"algorithmes",
                    r"visualisation de donn√©es",
                    r"traitement des donn√©es"
                ],
                "responses": [
                    "En Data Science, je travaille principalement avec :\n\n- Pandas pour la manipulation et l'analyse de donn√©es\n\n- Numpy pour les calculs math√©matiques et le traitement de tableaux\n\n- Seaborn pour la visualisation de donn√©es statistiques\n\nCes outils sont essentiels pour l'exploration, l'analyse et la visualisation des donn√©es dans mes projets."
                ]
            }
        }

        # Historique et analyse des sentiments
        self.conversation_history = []
        self.sentiment_history = []
        self.positive_words = set(['merci', 'super', 'g√©nial', 'genial', 'excellent', 'excelent',
                                   'bien', 'cool', 'manifik', 'magnifique', 'parfait', 'parf√©'])
        self.negative_words = set(['nul', 'mauvai', 'mauvais', 'terrible', 'terible', 'mal',
                                   'pas', 'pourit', 'pourri', 'naze'])

    def get_welcome_message(self):
        """Retourne le message de bienvenue initial format√© en JSON"""
        welcome_message = {
            "message": ("Bonjour ! Je suis Mohammad-Qassem, d√©veloppeur web fullstack.\n\n\n"
                        "Je peux vous parler de :\n\n\n"
                        "1. Mes projets (O'Foot, Oflix)\n\n\n"
                        "2. Mon parcours\n\n\n"
                        "3. Mes comp√©tences\n\n\n"
                        "N'h√©sitez pas √† me dire 'Bonjour' ou 'Salut' pour commencer !")
        }
        return welcome_message

    def get_response(self, user_input):
        """Traite l'entr√©e utilisateur et retourne une r√©ponse appropri√©e"""
        # Suppression de la v√©rification du premier message
        if not user_input.strip():
            return "Que souhaitez-vous savoir sur mon parcours ?"

        # Questions sp√©cifiques
        user_input = user_input.lower()
        if user_input.startswith("quel est votre √¢ge"):
            return "J'ai 22 ans."
        elif user_input.startswith("comment tu t'appelles"):
            return "Je m'appelle Mohammad-Qassem."

        # Traitement normal des messages
        response = self.find_match(user_input)
        self.save_to_history(user_input, response)
        return response

    def get_project_details(self, text):
        """Retourne les d√©tails d'un projet sp√©cifique"""
        text = text.lower()
        if "o'foot" in text or "ofoot" in text or "tournoi" in text:
            return self.project_details["ofoot"]
        elif "oflix" in text or "film" in text or "s√©rie" in text:
            return self.project_details["oflix"]
        elif "portfolio" in text:
            return self.project_details["portfolio"]
        return "Pouvez-vous pr√©ciser quel projet vous int√©resse ? O'Foot, Oflix ou le Portfolio ?\n\n\n"

    def correct_spelling(self, text):
        """Corrige l'orthographe du texte"""
        words = text.lower().split()
        return ' '.join(self.spelling_corrections.get(word, word) for word in words)

    def clean_text(self, text):
        """Nettoie et normalise le texte"""
        text = text.lower()
        text = self.correct_spelling(text)
        text = text.translate(str.maketrans("", "", string.punctuation))
        return " ".join(text.split())

    def calculate_similarity(self, text1, text2):
        """Calcule la similarit√© entre deux textes"""
        words1 = set(self.clean_text(text1).split())
        words2 = set(self.clean_text(text2).split())
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        return len(intersection) / len(union) if union else 0

    def find_match(self, user_input):
        """Trouve la meilleure r√©ponse correspondant √† l'entr√©e utilisateur"""
        corrected_input = self.clean_text(user_input)

        # Recherche de correspondance exacte
        for intent, data in self.knowledge_base.items():
            for pattern in data["patterns"]:
                if re.search(pattern, corrected_input, re.IGNORECASE):
                    response = random.choice(data["responses"])
                    return response(user_input) if callable(response) else response

        # Recherche par similarit√©
        best_match = None
        best_score = 0.2  # Seuil minimum de similarit√©

        for intent, data in self.knowledge_base.items():
            for pattern in data["patterns"]:
                clean_pattern = re.sub(r'[\.\*\[\]\(\)\?\+]', '', pattern)
                similarity = self.calculate_similarity(corrected_input, clean_pattern)
                if similarity > best_score:
                    best_score = similarity
                    response = random.choice(data["responses"])
                    best_match = response(user_input) if callable(response) else response

        if best_match:
            return best_match

        # R√©ponse par d√©faut
        return random.choice([
            "Je peux vous parler de mes projets, comp√©tences ou exp√©riences.\n\n\nQue souhaitez-vous savoir ?",
            "Je ne suis pas s√ªr de comprendre.\n\n\nVoulez-vous en savoir plus sur mon parcours, mes projets ou mes comp√©tences ?",
            "Pour mieux vous aider, dites-moi si vous voulez conna√Ætre mes r√©alisations, mon expertise technique ou mon exp√©rience."
        ])

    def save_to_history(self, user_input, bot_response):
        """Sauvegarde l'historique de la conversation et le sentiment"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        sentiment = self.analyze_sentiment(user_input)

        self.conversation_history.append({
            "timestamp": timestamp,
            "user": user_input,
            "bot": bot_response,
            "sentiment": sentiment
        })
        self.sentiment_history.append(sentiment)

    def analyze_sentiment(self, text):
        """Analyse le sentiment du message utilisateur"""
        words = text.lower().split()
        positive_count = sum(1 for word in words if word in self.positive_words)
        negative_count = sum(1 for word in words if word in self.negative_words)

        if positive_count > negative_count:
            return "positif"
        elif negative_count > positive_count:
            return "n√©gatif"
        return "neutre"